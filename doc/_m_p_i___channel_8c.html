<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI_Channel: src/MPI_Channel.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI_Channel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MPI_Channel.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of MPI Channel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="_m_p_i___channel_8h_source.html">MPI_Channel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_m_p_i___channel___struct_8h_source.html">MPI_Channel_Struct.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___s_p_s_c___s_y_n_c_8h_source.html">PT2PT/SPSC/PT2PT_SPSC_SYNC.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___s_p_s_c___b_u_f_8h_source.html">PT2PT/SPSC/PT2PT_SPSC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___m_p_s_c___s_y_n_c_8h_source.html">PT2PT/MPSC/PT2PT_MPSC_SYNC.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___m_p_s_c___b_u_f_8h_source.html">PT2PT/MPSC/PT2PT_MPSC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___m_p_m_c___s_y_n_c_8h_source.html">PT2PT/MPMC/PT2PT_MPMC_SYNC.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_t2_p_t___m_p_m_c___b_u_f_8h_source.html">PT2PT/MPMC/PT2PT_MPMC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___s_p_s_c___b_u_f_8h_source.html">RMA/SPSC/RMA_SPSC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___s_p_s_c___s_y_n_c_8h_source.html">RMA/SPSC/RMA_SPSC_SYNC.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h_source.html">RMA/MPSC/RMA_MPSC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___m_p_s_c___s_y_n_c_8h_source.html">RMA/MPSC/RMA_MPSC_SYNC.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___m_p_m_c___b_u_f_8h_source.html">RMA/MPMC/RMA_MPMC_BUF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_r_m_a___m_p_m_c___s_y_n_c_8h_source.html">RMA/MPMC/RMA_MPMC_SYNC.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abab94bdb4f4957c1902ab6faa228a3f6"><td class="memItemLeft" align="right" valign="top"><a id="abab94bdb4f4957c1902ab6faa228a3f6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>channel_peek_unsupported</b> ()</td></tr>
<tr class="separator:abab94bdb4f4957c1902ab6faa228a3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31">channel_alloc</a> (size_t size, int capacity, <a class="el" href="_m_p_i___channel_8h.html#a063b68851fad8232d6c805f65a35dabc">MPI_Communication_type</a> comm_type, MPI_Comm comm, int is_receiver)</td></tr>
<tr class="memdesc:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a fully constructed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> with passed parameter as channel properties.  <a href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31">More...</a><br /></td></tr>
<tr class="separator:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcee03cb6ada237310b69a3c1c4af2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a22fcee03cb6ada237310b69a3c1c4af2">channel_send</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:a22fcee03cb6ada237310b69a3c1c4af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. If the capacity of the channel is 1 or smaller a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> will block until a successfull and matching call of <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel as parameter has happenend. If the channel capacity is larger than 1 a call of <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> might only block if the internal buffer is full. On successful return the passed channel and data pointer might be used again.  <a href="_m_p_i___channel_8c.html#a22fcee03cb6ada237310b69a3c1c4af2">More...</a><br /></td></tr>
<tr class="separator:a22fcee03cb6ada237310b69a3c1c4af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09096d2a9b8839df93b789ddc554545c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a09096d2a9b8839df93b789ddc554545c">channel_receive</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:a09096d2a9b8839df93b789ddc554545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Analogous to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> a call of this function will block if the channel is unbuffered/synchronous and will only return if a matching <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> with the same channel as parameter is called. If the channel is buffered it might only block if the internal buffer is empty or rather the number of stored elements is 0. On successful return the passed channel and data pointer might be used again.  <a href="_m_p_i___channel_8c.html#a09096d2a9b8839df93b789ddc554545c">More...</a><br /></td></tr>
<tr class="separator:a09096d2a9b8839df93b789ddc554545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b038dbcaa372c4db26326099eca785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#ac8b038dbcaa372c4db26326099eca785">channel_peek</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:ac8b038dbcaa372c4db26326099eca785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the channel and returns a positive number if data can be sent or received. Since two sided communication differs vastly from one sided communication the return value also differs depending on wheter PT2PT or RMA is used as underlying communication type. If the communication type of the passed channel is PT2PT a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> returns the number of elements which can be sent (if the sender process calls) or 1 signaling that at least one element can be received (if the receiver process calls). If the communication type is RMA the returned value signals for both the sender and receiver how many elements can be sent and received respectively. If no element can be sent or received the returned value is 0. On successful return the passed channel might be used again.  <a href="_m_p_i___channel_8c.html#ac8b038dbcaa372c4db26326099eca785">More...</a><br /></td></tr>
<tr class="separator:ac8b038dbcaa372c4db26326099eca785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a9f25864a0b5070f4739ecd1c3e2abb09">channel_free</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> and frees all resources used for channel communication. Depending on the used communication and channel type a call of <a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09" title="Deallocates the passed MPI_Channel and frees all resources used for channel communication....">channel_free()</a> might fail: only freeing PT2PT BUF channels might lead to errors.  <a href="_m_p_i___channel_8c.html#a9f25864a0b5070f4739ecd1c3e2abb09">More...</a><br /></td></tr>
<tr class="separator:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8400333c54295af64c78a7447dafa789"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a8400333c54295af64c78a7447dafa789">channel_elem_size</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a8400333c54295af64c78a7447dafa789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the element size of the passed channel.  <a href="_m_p_i___channel_8c.html#a8400333c54295af64c78a7447dafa789">More...</a><br /></td></tr>
<tr class="separator:a8400333c54295af64c78a7447dafa789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1db322d2b17e5634dec7a55d26f91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a6da1db322d2b17e5634dec7a55d26f91">channel_capacity</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a6da1db322d2b17e5634dec7a55d26f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the passed channel is buffered or not.  <a href="_m_p_i___channel_8c.html#a6da1db322d2b17e5634dec7a55d26f91">More...</a><br /></td></tr>
<tr class="separator:a6da1db322d2b17e5634dec7a55d26f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52009977f3fe3ece1f037472ce38fe91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a52009977f3fe3ece1f037472ce38fe91">channel_type</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a52009977f3fe3ece1f037472ce38fe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks which channel type is used.  <a href="_m_p_i___channel_8c.html#a52009977f3fe3ece1f037472ce38fe91">More...</a><br /></td></tr>
<tr class="separator:a52009977f3fe3ece1f037472ce38fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#aebaabe9fdbf7d1d6a90ace730672ae9b">channel_comm_type</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks which communication type is used.  <a href="_m_p_i___channel_8c.html#aebaabe9fdbf7d1d6a90ace730672ae9b">More...</a><br /></td></tr>
<tr class="separator:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af493e31c8ec6a0f09e53d17951c78509"><td class="memItemLeft" align="right" valign="top">MPI_Group&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#af493e31c8ec6a0f09e53d17951c78509">channel_comm_group</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:af493e31c8ec6a0f09e53d17951c78509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the process group of the used communicator.  <a href="_m_p_i___channel_8c.html#af493e31c8ec6a0f09e53d17951c78509">More...</a><br /></td></tr>
<tr class="separator:af493e31c8ec6a0f09e53d17951c78509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2895a5548891c4770842bcda9340a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#ab2895a5548891c4770842bcda9340a93">channel_comm_size</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:ab2895a5548891c4770842bcda9340a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of processes used for the passed channel.  <a href="_m_p_i___channel_8c.html#ab2895a5548891c4770842bcda9340a93">More...</a><br /></td></tr>
<tr class="separator:ab2895a5548891c4770842bcda9340a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d02b4d03c28418772e9313b9df55af5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a5d02b4d03c28418772e9313b9df55af5">channel_sender_num</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a5d02b4d03c28418772e9313b9df55af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of senders used for the passed channel.  <a href="_m_p_i___channel_8c.html#a5d02b4d03c28418772e9313b9df55af5">More...</a><br /></td></tr>
<tr class="separator:a5d02b4d03c28418772e9313b9df55af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8c.html#a86ebd832af5a73e9fc6b46c6cb0cff43">channel_receiver_num</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of receivers used for the passed channel.  <a href="_m_p_i___channel_8c.html#a86ebd832af5a73e9fc6b46c6cb0cff43">More...</a><br /></td></tr>
<tr class="separator:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of MPI Channel. </p>
<dl class="section author"><dt>Author</dt><dd>Toni Hollfelder (<a href="#" onclick="location.href='mai'+'lto:'+'Ton'+'i.'+'Hol'+'lf'+'eld'+'er'+'@un'+'i-'+'bay'+'re'+'uth'+'.d'+'e'; return false;">Toni.<span style="display: none;">.nosp@m.</span>Holl<span style="display: none;">.nosp@m.</span>felde<span style="display: none;">.nosp@m.</span>r@un<span style="display: none;">.nosp@m.</span>i-bay<span style="display: none;">.nosp@m.</span>reut<span style="display: none;">.nosp@m.</span>h.de</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2021-01-04 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>CC BY 4.0 (<a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa8c734c22b85cf3b6833402b8b3c7b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c734c22b85cf3b6833402b8b3c7b31">&#9670;&nbsp;</a></span>channel_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a>* channel_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_p_i___channel_8h.html#a063b68851fad8232d6c805f65a35dabc">MPI_Communication_type</a>&#160;</td>
          <td class="paramname"><em>comm_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_receiver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and returns a fully constructed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> with passed parameter as channel properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of each data element the channel is supposed to transfer </td></tr>
    <tr><td class="paramname">capacity</td><td>The capacity which determines if the channel is buffered (size &gt; 0) and therefore asynchronous or unbuffered (size &lt;= 0) and therefore synchronous </td></tr>
    <tr><td class="paramname">comm_type</td><td>Determines the underlying communication of the channel. Can be either PT2PT or RMA. See the channel description for further details </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator of a group of processes. Every process of the communicator needs to call this function or else a deadlock will happen </td></tr>
    <tr><td class="paramname">is_receiver</td><td>This flag determines if the calling process is a receiver (is_receiver &gt;= 1) or sender (is_receiver &lt;=0). Depending on the count of receiver and sender the channel can be either SPSC, MPSC or MPMC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> if allocation was successfull, NULL otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might fail if:<ul>
<li>it is called with invalid parameter (e.g. wrong size or communicator, invalid number of sender or receiver),</li>
<li>MPI is not initialized,</li>
<li>memory allocation failed or</li>
<li>internal problems with MPI related functions happened</li>
</ul>
</dd>
<dd>
Depending on the number of receivers and senders three channel types are possible:<ul>
<li>Single Producer Single Consumer (SPSC): one sender and one receiver process,</li>
<li>Multiple Producer Single Consumer (MPSC): multiple sender and one receiver process or</li>
<li>Multiple Producer Multiple Conumser (MPMC): multiple sender and receiver processes</li>
<li>Furthermore as communication type can be used the two sided (PT2PT) or one sided (RMA) communication of MPI</li>
</ul>
</dd>
<dd>
For each communication and channel type an own implementation is used. Therefore using different channel and communication types can result in different runtimes </dd></dl>

</div>
</div>
<a id="a6da1db322d2b17e5634dec7a55d26f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da1db322d2b17e5634dec7a55d26f91">&#9670;&nbsp;</a></span>channel_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the passed channel is buffered or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the capacity of the channel if it's buffered, 0 otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="af493e31c8ec6a0f09e53d17951c78509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af493e31c8ec6a0f09e53d17951c78509">&#9670;&nbsp;</a></span>channel_comm_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Group channel_comm_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the process group of the used communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the process group of the used communicator </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="ab2895a5548891c4770842bcda9340a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2895a5548891c4770842bcda9340a93">&#9670;&nbsp;</a></span>channel_comm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_comm_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of processes used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the used communicator for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="aebaabe9fdbf7d1d6a90ace730672ae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaabe9fdbf7d1d6a90ace730672ae9b">&#9670;&nbsp;</a></span>channel_comm_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_comm_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks which communication type is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 for PT2PT and 1 for RMA </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a8400333c54295af64c78a7447dafa789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8400333c54295af64c78a7447dafa789">&#9670;&nbsp;</a></span>channel_elem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t channel_elem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the element size of the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the element size of the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a9f25864a0b5070f4739ecd1c3e2abb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f25864a0b5070f4739ecd1c3e2abb09">&#9670;&nbsp;</a></span>channel_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> and frees all resources used for channel communication. Depending on the used communication and channel type a call of <a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09" title="Deallocates the passed MPI_Channel and frees all resources used for channel communication....">channel_free()</a> might fail: only freeing PT2PT BUF channels might lead to errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if deallocation was succesfull and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are the usage of MPI's buffered send mode and the appending and shrinking of the buffer. </dd></dl>

</div>
</div>
<a id="ac8b038dbcaa372c4db26326099eca785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b038dbcaa372c4db26326099eca785">&#9670;&nbsp;</a></span>channel_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks at the channel and returns a positive number if data can be sent or received. Since two sided communication differs vastly from one sided communication the return value also differs depending on wheter PT2PT or RMA is used as underlying communication type. If the communication type of the passed channel is PT2PT a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> returns the number of elements which can be sent (if the sender process calls) or 1 signaling that at least one element can be received (if the receiver process calls). If the communication type is RMA the returned value signals for both the sender and receiver how many elements can be sent and received respectively. If no element can be sent or received the returned value is 0. On successful return the passed channel might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a positive number if elements can be sent or received and -1 if an error occures. See <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> description for further details on the return value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will only work for asychronous/buffered channels! For synchronous/unbuffered channels <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> will always return 1!</dd>
<dd>
If PT2PT is used as communication type a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> after a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> or <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel might still lead to an unchanged return value. This is due to the fact that MPI's MPI_Iprobe() only needs to guarantee progress. Therefore it might be necessary to busy call <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> until the element can be received or new elements can be sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a09096d2a9b8839df93b789ddc554545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09096d2a9b8839df93b789ddc554545c">&#9670;&nbsp;</a></span>channel_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Analogous to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> a call of this function will block if the channel is unbuffered/synchronous and will only return if a matching <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> with the same channel as parameter is called. If the channel is buffered it might only block if the internal buffer is empty or rather the number of stored elements is 0. On successful return the passed channel and data pointer might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be written to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if receiving was successful and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a86ebd832af5a73e9fc6b46c6cb0cff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebd832af5a73e9fc6b46c6cb0cff43">&#9670;&nbsp;</a></span>channel_receiver_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_receiver_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of receivers used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of receivers for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a22fcee03cb6ada237310b69a3c1c4af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcee03cb6ada237310b69a3c1c4af2">&#9670;&nbsp;</a></span>channel_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. If the capacity of the channel is 1 or smaller a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> will block until a successfull and matching call of <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel as parameter has happenend. If the channel capacity is larger than 1 a call of <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> might only block if the internal buffer is full. On successful return the passed channel and data pointer might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be sent from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if sending was successful and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions, failed memory allocation or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a5d02b4d03c28418772e9313b9df55af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d02b4d03c28418772e9313b9df55af5">&#9670;&nbsp;</a></span>channel_sender_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_sender_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of senders used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of senders for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a52009977f3fe3ece1f037472ce38fe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52009977f3fe3ece1f037472ce38fe91">&#9670;&nbsp;</a></span>channel_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks which channel type is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 for SPSC, 1 for MPSC and 2 for MPMC </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
