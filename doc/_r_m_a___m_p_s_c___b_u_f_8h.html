<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI_Channel: src/RMA/MPSC/RMA_MPSC_BUF.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI_Channel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_957240939c41b3e0b90ba346b14c999c.html">RMA</a></li><li class="navelem"><a class="el" href="dir_4b2ea471cdcd5efc43fc1a300eb7e159.html">MPSC</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RMA_MPSC_BUF.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header of RMA MPSC BUF Channel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_m_p_i___channel___struct_8h_source.html">../../MPI_Channel_Struct.h</a>&quot;</code><br />
</div>
<p><a href="_r_m_a___m_p_s_c___b_u_f_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a128a646d9763c70a1c41d559b5dd4046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a128a646d9763c70a1c41d559b5dd4046">channel_alloc_rma_mpsc_buf</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a128a646d9763c70a1c41d559b5dd4046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the properties of a passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF and returns it.  <a href="_r_m_a___m_p_s_c___b_u_f_8h.html#a128a646d9763c70a1c41d559b5dd4046">More...</a><br /></td></tr>
<tr class="separator:a128a646d9763c70a1c41d559b5dd4046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f60ef6073cc063cb60a4e607d24c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#aac9f60ef6073cc063cb60a4e607d24c7">channel_send_rma_mpsc_buf</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:aac9f60ef6073cc063cb60a4e607d24c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. Calling <a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#aac9f60ef6073cc063cb60a4e607d24c7" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send_rma_mpsc_buf()</a> blocks only if the channel buffer has reached the channel capacity.  <a href="_r_m_a___m_p_s_c___b_u_f_8h.html#aac9f60ef6073cc063cb60a4e607d24c7">More...</a><br /></td></tr>
<tr class="separator:aac9f60ef6073cc063cb60a4e607d24c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b3935b8da820e12b6f7be4be0293c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a772b3935b8da820e12b6f7be4be0293c">channel_receive_rma_mpsc_buf</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:a772b3935b8da820e12b6f7be4be0293c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Calling <a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a772b3935b8da820e12b6f7be4be0293c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive_rma_mpsc_buf()</a> blocks only if no element has arrived and the internal buffer stores no message.  <a href="_r_m_a___m_p_s_c___b_u_f_8h.html#a772b3935b8da820e12b6f7be4be0293c">More...</a><br /></td></tr>
<tr class="separator:a772b3935b8da820e12b6f7be4be0293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88794a0c89da356b37c4e3467ce932a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a88794a0c89da356b37c4e3467ce932a3">channel_peek_rma_mpsc_buf</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a88794a0c89da356b37c4e3467ce932a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the channel and signals if messages can be sent (sender process calls) or received (receiver process calls).  <a href="_r_m_a___m_p_s_c___b_u_f_8h.html#a88794a0c89da356b37c4e3467ce932a3">More...</a><br /></td></tr>
<tr class="separator:a88794a0c89da356b37c4e3467ce932a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359c79aa3c6dc0727b15327dbfd42920"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a359c79aa3c6dc0727b15327dbfd42920">channel_free_rma_mpsc_buf</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a359c79aa3c6dc0727b15327dbfd42920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the channel and all allocated members.  <a href="_r_m_a___m_p_s_c___b_u_f_8h.html#a359c79aa3c6dc0727b15327dbfd42920">More...</a><br /></td></tr>
<tr class="separator:a359c79aa3c6dc0727b15327dbfd42920"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header of RMA MPSC BUF Channel. </p>
<dl class="section author"><dt>Author</dt><dd>Toni Hollfelder (<a href="#" onclick="location.href='mai'+'lto:'+'Ton'+'i.'+'Hol'+'lf'+'eld'+'er'+'@un'+'i-'+'bay'+'re'+'uth'+'.d'+'e'; return false;">Toni.<span style="display: none;">.nosp@m.</span>Holl<span style="display: none;">.nosp@m.</span>felde<span style="display: none;">.nosp@m.</span>r@un<span style="display: none;">.nosp@m.</span>i-bay<span style="display: none;">.nosp@m.</span>reut<span style="display: none;">.nosp@m.</span>h.de</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2021-05-19 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>CC BY 4.0 (<a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>)</dd></dl>
<p>This RMA MPSC BUF channel implementation use passive target communication and especially a modified version of the nonblocking M&amp;S queue algorithm. It is modified so that this implementation is fair and starvation-free and notably wait-free for sender and receiver process.</p>
<p>Layout of local window memory of each process depending on sender or receiver process: Sender: | READ | WRITE | NODE_1 | ... | NODE_N | where NODE is | NEXT_NODE | DATA | Receiver: | HEAD_REF | TAIL_REF | A node adress consists of the rank of the sender multiplied by the channel capacity plus the locally used write index.</p>
<p>Every sender stores the data as nodes locally in a circular buffer and the read and write index. It waits until there is enough space for a new node. Then it creates a new node and fills it with the data. It atomically exchanges the adress to the node with the adress of the tail at the receiver process. If the tail stores the value -1 the node is the first node in the distributed list. The sender then also needs to update the head pointer. If the tail stores the adress to another node, the sender needs to update the next node pointer at the previous tail node. The receiver waits until the head pointer points to a node. It loads the head node adress and calculates the sender rank and the node offset. The receiver waits until the current sender variable is atomically updated, resets the current sender variable, gets the data and wakes the current sender up. It loads the data and the next node from the sender process and needs to check if the next node variable stores the adress of another node (!=-1) or not (=-1). If another adress is stored it sets the head pointer to this new adress. If no adress is stored the receiver process needs to check if the tail pointer points to another node that the head pointer points to. If this is the case the receiver process needs to wait until the sender process updates the head pointer. But if head and tail pointer point to the same node, the receiver process tries to atomically exchange the tail pointer with -1 signaling that the last node has been consumed and a new sender process needs to attach a new node without previous node reference. After updating the head and possibly tail pointer the receiver process only needs to update the new read index and write it back to the sender process of the head node.</p>
<p>This implementation has been compared to two implementations where one uses MPI's MPI_EXCLUSIVE_LOCK and the other one uses MPI's MPI_SHARED_LOCK and a distributed lock. The first one has the problem that there cannot be made a statement of the order of accesses of the sender processes leading to potential starvation of sender processes. The second implementation works without problems but shows a slower execution time and does only allow a access of exactly one sender process at a time while the nonblocking algorithm allows concurrent access of all processes at a time. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a128a646d9763c70a1c41d559b5dd4046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128a646d9763c70a1c41d559b5dd4046">&#9670;&nbsp;</a></span>channel_alloc_rma_mpsc_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a>* channel_alloc_rma_mpsc_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the properties of a passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to a valid <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> with updated properties if updating was successful and NULL otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns NULL if MPI related functions or allocation memory failure happend. </dd></dl>

</div>
</div>
<a id="a359c79aa3c6dc0727b15327dbfd42920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359c79aa3c6dc0727b15327dbfd42920">&#9670;&nbsp;</a></span>channel_free_rma_mpsc_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_free_rma_mpsc_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the channel and all allocated members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 since deallocation is always successfull </dd></dl>

</div>
</div>
<a id="a88794a0c89da356b37c4e3467ce932a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88794a0c89da356b37c4e3467ce932a3">&#9670;&nbsp;</a></span>channel_peek_rma_mpsc_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_peek_rma_mpsc_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks at the channel and signals if messages can be sent (sender process calls) or received (receiver process calls). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of elements which can be sent if the sender process calls and 1 or 0 depending on at least one buffered item if the receiver process calls. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns -1 if internal problems with MPI related functions happen. </dd></dl>

</div>
</div>
<a id="a772b3935b8da820e12b6f7be4be0293c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772b3935b8da820e12b6f7be4be0293c">&#9670;&nbsp;</a></span>channel_receive_rma_mpsc_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_receive_rma_mpsc_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Calling <a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#a772b3935b8da820e12b6f7be4be0293c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive_rma_mpsc_buf()</a> blocks only if no element has arrived and the internal buffer stores no message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be received to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if receiving was successful, -1 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns -1 if internal problems with MPI related functions happend. </dd></dl>

</div>
</div>
<a id="aac9f60ef6073cc063cb60a4e607d24c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f60ef6073cc063cb60a4e607d24c7">&#9670;&nbsp;</a></span>channel_send_rma_mpsc_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send_rma_mpsc_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8c.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. Calling <a class="el" href="_r_m_a___m_p_s_c___b_u_f_8h.html#aac9f60ef6073cc063cb60a4e607d24c7" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send_rma_mpsc_buf()</a> blocks only if the channel buffer has reached the channel capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> of type RMA MPSC BUF. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be sent from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if sending was successful, -1 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns -1 if internal problems with MPI related functions happend. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
