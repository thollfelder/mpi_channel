<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI_Channel: src/MPI_Channel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI_Channel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MPI_Channel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header of MPI Channel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;mpi.h&quot;</code><br />
</div>
<p><a href="_m_p_i___channel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5a179f12a6f74d9a507d5fb67d75c344"><td class="memItemLeft" align="right" valign="top"><a id="a5a179f12a6f74d9a507d5fb67d75c344"></a>
typedef enum MPI_Chan_type&#160;</td><td class="memItemRight" valign="bottom"><b>MPI_Channel_type</b></td></tr>
<tr class="separator:a5a179f12a6f74d9a507d5fb67d75c344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063b68851fad8232d6c805f65a35dabc"><td class="memItemLeft" align="right" valign="top"><a id="a063b68851fad8232d6c805f65a35dabc"></a>
typedef enum <a class="el" href="_m_p_i___channel_8h.html#adb3c9c9321f9db93f890f12a4e78f62f">MPI_Comm_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a063b68851fad8232d6c805f65a35dabc">MPI_Communication_type</a></td></tr>
<tr class="memdesc:a063b68851fad8232d6c805f65a35dabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum used for determing MPI communication type of channel implementation. <br /></td></tr>
<tr class="separator:a063b68851fad8232d6c805f65a35dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a882169a80df7ddfe0d0f7cb773c73"><td class="memItemLeft" align="right" valign="top"><a id="ab9a882169a80df7ddfe0d0f7cb773c73"></a>
typedef struct <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MPI_Channel</b></td></tr>
<tr class="separator:ab9a882169a80df7ddfe0d0f7cb773c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adb3c9c9321f9db93f890f12a4e78f62f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#adb3c9c9321f9db93f890f12a4e78f62f">MPI_Comm_type</a> { <b>PT2PT</b>
, <a class="el" href="_m_p_i___channel_8h.html#adb3c9c9321f9db93f890f12a4e78f62face9c970586c2aa2ab4130c2e63a54b85">RMA</a>
, <b>PT2PT</b>
, <b>RMA</b>
 }</td></tr>
<tr class="memdesc:adb3c9c9321f9db93f890f12a4e78f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum used for determing MPI communication type of channel implementation.  <a href="_m_p_i___channel_8h.html#adb3c9c9321f9db93f890f12a4e78f62f">More...</a><br /></td></tr>
<tr class="separator:adb3c9c9321f9db93f890f12a4e78f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31">channel_alloc</a> (size_t size, int capacity, <a class="el" href="_m_p_i___channel_8h.html#a063b68851fad8232d6c805f65a35dabc">MPI_Communication_type</a> comm_type, MPI_Comm comm, int is_receiver)</td></tr>
<tr class="memdesc:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a fully constructed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> with passed parameter as channel properties.  <a href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31">More...</a><br /></td></tr>
<tr class="separator:aa8c734c22b85cf3b6833402b8b3c7b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcee03cb6ada237310b69a3c1c4af2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2">channel_send</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:a22fcee03cb6ada237310b69a3c1c4af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. If the capacity of the channel is 1 or smaller a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> will block until a successfull and matching call of <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel as parameter has happenend. If the channel capacity is larger than 1 a call of <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> might only block if the internal buffer is full. On successful return the passed channel and data pointer might be used again.  <a href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2">More...</a><br /></td></tr>
<tr class="separator:a22fcee03cb6ada237310b69a3c1c4af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09096d2a9b8839df93b789ddc554545c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c">channel_receive</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch, void *data)</td></tr>
<tr class="memdesc:a09096d2a9b8839df93b789ddc554545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Analogous to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> a call of this function will block if the channel is unbuffered/synchronous and will only return if a matching <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> with the same channel as parameter is called. If the channel is buffered it might only block if the internal buffer is empty or rather the number of stored elements is 0. On successful return the passed channel and data pointer might be used again.  <a href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c">More...</a><br /></td></tr>
<tr class="separator:a09096d2a9b8839df93b789ddc554545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b038dbcaa372c4db26326099eca785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785">channel_peek</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:ac8b038dbcaa372c4db26326099eca785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the channel and returns a positive number if data can be sent or received. Since two sided communication differs vastly from one sided communication the return value also differs depending on wheter PT2PT or RMA is used as underlying communication type. If the communication type of the passed channel is PT2PT a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> returns the number of elements which can be sent (if the sender process calls) or 1 signaling that at least one element can be received (if the receiver process calls). If the communication type is RMA the returned value signals for both the sender and receiver how many elements can be sent and received respectively. If no element can be sent or received the returned value is 0. On successful return the passed channel might be used again.  <a href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785">More...</a><br /></td></tr>
<tr class="separator:ac8b038dbcaa372c4db26326099eca785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09">channel_free</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> and frees all resources used for channel communication. Depending on the used communication and channel type a call of <a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09" title="Deallocates the passed MPI_Channel and frees all resources used for channel communication....">channel_free()</a> might fail: only freeing PT2PT BUF channels might lead to errors.  <a href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09">More...</a><br /></td></tr>
<tr class="separator:a9f25864a0b5070f4739ecd1c3e2abb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8400333c54295af64c78a7447dafa789"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a8400333c54295af64c78a7447dafa789">channel_elem_size</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a8400333c54295af64c78a7447dafa789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the element size of the passed channel.  <a href="_m_p_i___channel_8h.html#a8400333c54295af64c78a7447dafa789">More...</a><br /></td></tr>
<tr class="separator:a8400333c54295af64c78a7447dafa789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1db322d2b17e5634dec7a55d26f91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a6da1db322d2b17e5634dec7a55d26f91">channel_capacity</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a6da1db322d2b17e5634dec7a55d26f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the passed channel is buffered or not.  <a href="_m_p_i___channel_8h.html#a6da1db322d2b17e5634dec7a55d26f91">More...</a><br /></td></tr>
<tr class="separator:a6da1db322d2b17e5634dec7a55d26f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52009977f3fe3ece1f037472ce38fe91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a52009977f3fe3ece1f037472ce38fe91">channel_type</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a52009977f3fe3ece1f037472ce38fe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks which channel type is used.  <a href="_m_p_i___channel_8h.html#a52009977f3fe3ece1f037472ce38fe91">More...</a><br /></td></tr>
<tr class="separator:a52009977f3fe3ece1f037472ce38fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#aebaabe9fdbf7d1d6a90ace730672ae9b">channel_comm_type</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks which communication type is used.  <a href="_m_p_i___channel_8h.html#aebaabe9fdbf7d1d6a90ace730672ae9b">More...</a><br /></td></tr>
<tr class="separator:aebaabe9fdbf7d1d6a90ace730672ae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af493e31c8ec6a0f09e53d17951c78509"><td class="memItemLeft" align="right" valign="top">MPI_Group&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#af493e31c8ec6a0f09e53d17951c78509">channel_comm_group</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:af493e31c8ec6a0f09e53d17951c78509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the process group of the used communicator.  <a href="_m_p_i___channel_8h.html#af493e31c8ec6a0f09e53d17951c78509">More...</a><br /></td></tr>
<tr class="separator:af493e31c8ec6a0f09e53d17951c78509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2895a5548891c4770842bcda9340a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#ab2895a5548891c4770842bcda9340a93">channel_comm_size</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:ab2895a5548891c4770842bcda9340a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of processes used for the passed channel.  <a href="_m_p_i___channel_8h.html#ab2895a5548891c4770842bcda9340a93">More...</a><br /></td></tr>
<tr class="separator:ab2895a5548891c4770842bcda9340a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d02b4d03c28418772e9313b9df55af5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a5d02b4d03c28418772e9313b9df55af5">channel_sender_num</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a5d02b4d03c28418772e9313b9df55af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of senders used for the passed channel.  <a href="_m_p_i___channel_8h.html#a5d02b4d03c28418772e9313b9df55af5">More...</a><br /></td></tr>
<tr class="separator:a5d02b4d03c28418772e9313b9df55af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_i___channel_8h.html#a86ebd832af5a73e9fc6b46c6cb0cff43">channel_receiver_num</a> (<a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *ch)</td></tr>
<tr class="memdesc:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the number of receivers used for the passed channel.  <a href="_m_p_i___channel_8h.html#a86ebd832af5a73e9fc6b46c6cb0cff43">More...</a><br /></td></tr>
<tr class="separator:a86ebd832af5a73e9fc6b46c6cb0cff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header of MPI Channel. </p>
<dl class="section author"><dt>Author</dt><dd>Toni Hollfelder (<a href="#" onclick="location.href='mai'+'lto:'+'Ton'+'i.'+'Hol'+'lf'+'eld'+'er'+'@un'+'i-'+'bay'+'re'+'uth'+'.d'+'e'; return false;">Toni.<span style="display: none;">.nosp@m.</span>Holl<span style="display: none;">.nosp@m.</span>felde<span style="display: none;">.nosp@m.</span>r@un<span style="display: none;">.nosp@m.</span>i-bay<span style="display: none;">.nosp@m.</span>reut<span style="display: none;">.nosp@m.</span>h.de</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2021-01-04 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>CC BY 4.0 (<a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>)</dd></dl>
<p>This channel implementation originated from my bachelor thesis "Design und Implementierung von Channels im
verteilten Adressraum" at the University of Bayreuth, and is intended to be used on clusters with distributed adress space using MPI as a communication library.</p>
<p>The channels can be categorized into three classes: The first one is the underlying communication type MPI offers, the second one is the channel type itself and how many sender and receiver take part in the communication, while the third one is the capacity of the channel itself.</p>
<p>For the communication type, MPI offers two-sided communication (also called point to point or PT2PT) and one-sided communication (also called remote memory access or RMA). PT2PT uses message passing while RMA uses shared memory communication. The channels can be further categorized in SPSC (single producer single consumer), MPSC (multiple producer single consumer) and MPMC (multiple producer multiple consumer). Lastly the channels can be either buffered and asynchronous or unbuffered and synchronous. Regarding these classifications, this channel offers a total of 12 different channel implementations which are abbreviated as {PT2PT|RMA}_{SPSC|MPSC|MPMC}_{SYNC|BUF}. Using different channel and communication types allows for a more optimized implementation.</p>
<p>Using advice: To use this channel implementation, channels can be allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> which needs the following parameters: The data size, the channel capacity, the communication type, the communicator and an integer flag stating whether the calling process is a receiver or a sender. It's important that every process of the communicator calls the <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> function, otherwise a deadlock occures. To free the channel <a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09" title="Deallocates the passed MPI_Channel and frees all resources used for channel communication....">channel_free()</a> needs to be used with the <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> reference <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> returns. For both, buffered and synchronous channels, calls to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> and <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> are always blocking until the element has been sent or received. The difference between those channels is that synchronous channels need a matching send and receive call before the corresponding functions return while buffered channels can send and receive without a matching send/receive call as long as the channel buffer is reaching 0 or the channel capacity. To check the current buffer capacity of a channel when using buffered channels <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> might be used.</p>
<p>Important notes: In general, runtime experiments for MPICH and OpenMPI on clusters running on one and on different nodes have shown the following observations: PT2PT &gt; RMA, SPSC &gt; MPSC &gt; MPMC, BUF &gt; SYNC where "&gt;" states a better runtime.</p>
<p>As an important side note: To make this channel implementation as portable as MPI itself, no threading library was used. This means that this implementation uses neither threads nor is it allowed to be run with multiple threads.</p>
<p>To get error, warning or debug messages the corresponding flags can be set to either 1 or 0 in <a class="el" href="_m_p_i___channel___struct_8h.html" title="Header of MPI Channel Struct.">MPI_Channel_Struct.h</a></p>
<p>One of the main goals of this channel implementation is to preserve high portability going without a thread library and to provide a channel implementation which is highly fair and starvation-free and gives the highest progress conditions possible taking efficiency into consideration (wait-free, etc.). </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adb3c9c9321f9db93f890f12a4e78f62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3c9c9321f9db93f890f12a4e78f62f">&#9670;&nbsp;</a></span>MPI_Comm_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_m_p_i___channel_8h.html#adb3c9c9321f9db93f890f12a4e78f62f">MPI_Comm_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum used for determing MPI communication type of channel implementation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb3c9c9321f9db93f890f12a4e78f62face9c970586c2aa2ab4130c2e63a54b85"></a>RMA&#160;</td><td class="fielddoc"><p>Two sided communication One sided communication </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa8c734c22b85cf3b6833402b8b3c7b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c734c22b85cf3b6833402b8b3c7b31">&#9670;&nbsp;</a></span>channel_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a>* channel_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_p_i___channel_8h.html#a063b68851fad8232d6c805f65a35dabc">MPI_Communication_type</a>&#160;</td>
          <td class="paramname"><em>comm_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_receiver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and returns a fully constructed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> with passed parameter as channel properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of each data element the channel is supposed to transfer </td></tr>
    <tr><td class="paramname">capacity</td><td>The capacity which determines if the channel is buffered (size &gt; 0) and therefore asynchronous or unbuffered (size &lt;= 0) and therefore synchronous </td></tr>
    <tr><td class="paramname">comm_type</td><td>Determines the underlying communication of the channel. Can be either PT2PT or RMA. See the channel description for further details </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator of a group of processes. Every process of the communicator needs to call this function or else a deadlock will happen </td></tr>
    <tr><td class="paramname">is_receiver</td><td>This flag determines if the calling process is a receiver (is_receiver &gt;= 1) or sender (is_receiver &lt;=0). Depending on the count of receiver and sender the channel can be either SPSC, MPSC or MPMC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> if allocation was successfull, NULL otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might fail if:<ul>
<li>it is called with invalid parameter (e.g. wrong size or communicator, invalid number of sender or receiver),</li>
<li>MPI is not initialized,</li>
<li>memory allocation failed or</li>
<li>internal problems with MPI related functions happened</li>
</ul>
</dd>
<dd>
Depending on the number of receivers and senders three channel types are possible:<ul>
<li>Single Producer Single Consumer (SPSC): one sender and one receiver process,</li>
<li>Multiple Producer Single Consumer (MPSC): multiple sender and one receiver process or</li>
<li>Multiple Producer Multiple Conumser (MPMC): multiple sender and receiver processes</li>
<li>Furthermore as communication type can be used the two sided (PT2PT) or one sided (RMA) communication of MPI</li>
</ul>
</dd>
<dd>
For each communication and channel type an own implementation is used. Therefore using different channel and communication types can result in different runtimes </dd></dl>

</div>
</div>
<a id="a6da1db322d2b17e5634dec7a55d26f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da1db322d2b17e5634dec7a55d26f91">&#9670;&nbsp;</a></span>channel_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the passed channel is buffered or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the capacity of the channel if it's buffered, 0 otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="af493e31c8ec6a0f09e53d17951c78509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af493e31c8ec6a0f09e53d17951c78509">&#9670;&nbsp;</a></span>channel_comm_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Group channel_comm_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the process group of the used communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the process group of the used communicator </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="ab2895a5548891c4770842bcda9340a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2895a5548891c4770842bcda9340a93">&#9670;&nbsp;</a></span>channel_comm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_comm_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of processes used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the used communicator for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="aebaabe9fdbf7d1d6a90ace730672ae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaabe9fdbf7d1d6a90ace730672ae9b">&#9670;&nbsp;</a></span>channel_comm_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_comm_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks which communication type is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 for PT2PT and 1 for RMA </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a8400333c54295af64c78a7447dafa789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8400333c54295af64c78a7447dafa789">&#9670;&nbsp;</a></span>channel_elem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t channel_elem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the element size of the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the element size of the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a9f25864a0b5070f4739ecd1c3e2abb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f25864a0b5070f4739ecd1c3e2abb09">&#9670;&nbsp;</a></span>channel_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the passed <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> and frees all resources used for channel communication. Depending on the used communication and channel type a call of <a class="el" href="_m_p_i___channel_8h.html#a9f25864a0b5070f4739ecd1c3e2abb09" title="Deallocates the passed MPI_Channel and frees all resources used for channel communication....">channel_free()</a> might fail: only freeing PT2PT BUF channels might lead to errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if deallocation was succesfull and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are the usage of MPI's buffered send mode and the appending and shrinking of the buffer. </dd></dl>

</div>
</div>
<a id="ac8b038dbcaa372c4db26326099eca785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b038dbcaa372c4db26326099eca785">&#9670;&nbsp;</a></span>channel_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks at the channel and returns a positive number if data can be sent or received. Since two sided communication differs vastly from one sided communication the return value also differs depending on wheter PT2PT or RMA is used as underlying communication type. If the communication type of the passed channel is PT2PT a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> returns the number of elements which can be sent (if the sender process calls) or 1 signaling that at least one element can be received (if the receiver process calls). If the communication type is RMA the returned value signals for both the sender and receiver how many elements can be sent and received respectively. If no element can be sent or received the returned value is 0. On successful return the passed channel might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a positive number if elements can be sent or received and -1 if an error occures. See <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> description for further details on the return value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will only work for asychronous/buffered channels! For synchronous/unbuffered channels <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> will always return 1!</dd>
<dd>
If PT2PT is used as communication type a call to <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> after a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> or <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel might still lead to an unchanged return value. This is due to the fact that MPI's MPI_Iprobe() only needs to guarantee progress. Therefore it might be necessary to busy call <a class="el" href="_m_p_i___channel_8h.html#ac8b038dbcaa372c4db26326099eca785" title="Peeks at the channel and returns a positive number if data can be sent or received....">channel_peek()</a> until the element can be received or new elements can be sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a09096d2a9b8839df93b789ddc554545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09096d2a9b8839df93b789ddc554545c">&#9670;&nbsp;</a></span>channel_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> from the channel and stores them starting at the adress the void pointer holds. Analogous to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> a call of this function will block if the channel is unbuffered/synchronous and will only return if a matching <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> with the same channel as parameter is called. If the channel is buffered it might only block if the internal buffer is empty or rather the number of stored elements is 0. On successful return the passed channel and data pointer might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be written to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if receiving was successful and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a86ebd832af5a73e9fc6b46c6cb0cff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebd832af5a73e9fc6b46c6cb0cff43">&#9670;&nbsp;</a></span>channel_receiver_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_receiver_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of receivers used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of receivers for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a22fcee03cb6ada237310b69a3c1c4af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcee03cb6ada237310b69a3c1c4af2">&#9670;&nbsp;</a></span>channel_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the numbers of bytes of a data element specified in <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> starting at the adress the void pointer holds into the channel. If the capacity of the channel is 1 or smaller a call to <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> will block until a successfull and matching call of <a class="el" href="_m_p_i___channel_8h.html#a09096d2a9b8839df93b789ddc554545c" title="Receives the numbers of bytes of a data element specified in channel_alloc() from the channel and sto...">channel_receive()</a> with the same channel as parameter has happenend. If the channel capacity is larger than 1 a call of <a class="el" href="_m_p_i___channel_8h.html#a22fcee03cb6ada237310b69a3c1c4af2" title="Sends the numbers of bytes of a data element specified in channel_alloc() starting at the adress the ...">channel_send()</a> might only block if the internal buffer is full. On successful return the passed channel and data pointer might be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a memory adress of which size bytes will be sent from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if sending was successful and -1 if an error occures</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reasons for errors are either internal problems with MPI related functions, failed memory allocation or wrong usage of this function (e.g. passing a NULL pointer) </dd></dl>

</div>
</div>
<a id="a5d02b4d03c28418772e9313b9df55af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d02b4d03c28418772e9313b9df55af5">&#9670;&nbsp;</a></span>channel_sender_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_sender_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the number of senders used for the passed channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of senders for the passed channel </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
<a id="a52009977f3fe3ece1f037472ce38fe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52009977f3fe3ece1f037472ce38fe91">&#9670;&nbsp;</a></span>channel_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks which channel type is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ch</td><td>Pointer to a <a class="el" href="struct_m_p_i___channel.html">MPI_Channel</a> allocated with <a class="el" href="_m_p_i___channel_8h.html#aa8c734c22b85cf3b6833402b8b3c7b31" title="Allocates and returns a fully constructed MPI_Channel with passed parameter as channel properties.">channel_alloc()</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 for SPSC, 1 for MPSC and 2 for MPMC </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot fail and is therefore marked as NOTHROW </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
